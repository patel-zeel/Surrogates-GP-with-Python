{
  
    
        "post0": {
            "title": "Chapter 1",
            "content": "Content . import plotly.express as px import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from matplotlib import rc import pandas as pd import numpy as np rc(&#39;font&#39;,size=12) . Simple order 1 polynomial: $ eta = 50 + 8x_1 + 3x_2$ . def first_order(x1, x2): return 50 + 8*x1 + 3*x2 fig, ax = plt.subplots() x1 = x2 = np.linspace(-1,1,100) X1, X2 = np.meshgrid(x1, x2) z = first_order(X1, X2) cntr = plt.contour(X1, X2, z, levels=20);plt.xlabel(&#39;X1&#39;);plt.ylabel(&#39;X2&#39;); plt.xticks([-1,-0.5,0,0.5,1]);plt.yticks([-1,-0.5,0,0.5,1]) ax.clabel(cntr) plt.colorbar(); . Adding interaction term: $ eta = 50 + 8x_1 + 3x_2 - 4x_1x_2$ . def first_order_i(x1, x2, c0=50, c1=8, c2=3, c3=4): return c0 + c1*x1 + c2*x2 - c3*x1*x2 x1 = x2 = np.linspace(-1,1,100) X1, X2 = np.meshgrid(x1, x2) fig, ax = plt.subplots() def update(c3): ax.cla() z = first_order_i(X1, X2, c3=c3) cntr = ax.contour(X1, X2, z, levels=20); ax.set_xlabel(&#39;X1&#39;);ax.set_ylabel(&#39;X2&#39;); ax.set_xticks([-1,-0.5,0,0.5,1]);ax.set_yticks([-1,-0.5,0,0.5,1]) ax.clabel(cntr); ax.set_title(&#39;c3 = &#39;+str(c3)) anim = FuncAnimation(fig, update, frames=np.arange(-4,5)) plt.close() rc(&#39;animation&#39;,html=&#39;jshtml&#39;) anim . &lt;/input&gt; Once Loop Reflect Adding squared terms: $ eta = 50 + 8x_1 + 3x_2 - 7x_1^2 - 3x_2^2 - 4x_1x_2$ . def simple_max(x1, x2, c0=50, c1=8, c2=3, c3=7, c4=3, c5=4): return c0 + c1*x1 + c2*x2 - c3*np.square(x1) - c4*np.square(x2) - c5*x1*x2 x1 = x2 = np.linspace(-1,1,100) X1, X2 = np.meshgrid(x1, x2) fig, ax = plt.subplots() def update(c3): ax.cla() z = simple_max(X1, X2, c3=c3) cntr = ax.contour(X1, X2, z, levels=20); ax.set_xlabel(&#39;X1&#39;);ax.set_ylabel(&#39;X2&#39;); ax.set_xticks([-1,-0.5,0,0.5,1]);ax.set_yticks([-1,-0.5,0,0.5,1]) ax.clabel(cntr); ax.set_title(&#39;c3 = &#39;+str(c3)) anim = FuncAnimation(fig, update, frames=np.arange(7-3,7+4)) plt.close() rc(&#39;animation&#39;,html=&#39;jshtml&#39;) anim . &lt;/input&gt; Once Loop Reflect Stationary ridge: $ eta = 80+4x_1+8x_2-3x_1^2-12x_2^2-12x_1x_2$ . def stat_ridge(x1, x2, c1=80, c2=4, c3=8, c4=3, c5=12, c6=12): return c1 + c2*x1 + c3*x2 - c4*np.square(x1) - c5*np.square(x2) - c6*x1*x2 x1 = x2 = np.linspace(-1,1,100) X1, X2 = np.meshgrid(x1, x2) fig, ax = plt.subplots() def update(c2): ax.cla() z = stat_ridge(X1, X2, c2=c2) cntr = ax.contour(X1, X2, z, levels=20); ax.set_xlabel(&#39;X1&#39;);ax.set_ylabel(&#39;X2&#39;); ax.set_xticks([-1,-0.5,0,0.5,1]);ax.set_yticks([-1,-0.5,0,0.5,1]) ax.clabel(cntr); ax.set_title(&#39;c2 = &#39;+str(c2)) anim = FuncAnimation(fig, update, frames=np.arange(-4,9)) plt.close() rc(&#39;animation&#39;,html=&#39;jshtml&#39;) anim . &lt;/input&gt; Once Loop Reflect Saddle point: $ eta = 80 + 4x_1 + 8x_2 - 2x_1 - 12x_2 - 12x_1x_2$ . def saddle(x1, x2, c0=80, c1=4, c2=8, c3=2, c4=12, c5=12): return c0 + c1*x1 + c2*x2 - c3*x1 - c4*x2 - c5*x1*x2 fig, ax = plt.subplots() x1 = x2 = np.linspace(-1,1,100) X1, X2 = np.meshgrid(x1, x2) z = saddle(X1, X2) cntr = plt.contour(X1, X2, z, levels=20);plt.xlabel(&#39;X1&#39;);plt.ylabel(&#39;X2&#39;); plt.xticks([-1,-0.5,0,0.5,1]);plt.yticks([-1,-0.5,0,0.5,1]) ax.clabel(cntr); . Aircraft wing weight example (1.2.1) . The weight of aircraft is considered a function of 9 parameters given by following equation, $$ W = 0.036 S_{ mathrm{w}}^{0.758} W_{ mathrm{fw}}^{0.0035} left( frac{A}{ cos^2 Lambda} right)^{0.6} q^{0.006} lambda^{0.04} left( frac{100 R_{ mathrm{tc}}}{ cos Lambda} right)^{-0.3} (N_{ mathrm{z}} W_{ mathrm{dg}})^{0.49} $$ . def wingwt(Sw=0.48, Wfw=0.4, A=0.38, L=0.5, q=0.62, l=0.344, Rtc=0.4, Nz=0.37, Wdg=0.38): ## put coded inputs back on natural scale Sw = Sw*(200 - 150) + 150 Wfw = Wfw*(300 - 220) + 220 A = A*(10 - 6) + 6 L = (L*(10 - (-10)) - 10) * np.pi/180 q = q*(45 - 16) + 16 l = l*(1 - 0.5) + 0.5 Rtc = Rtc*(0.18 - 0.08) + 0.08 Nz = Nz*(6 - 2.5) + 2.5 Wdg = Wdg*(2500 - 1700) + 1700 ## calculation on natural scale W = 0.036*Sw**0.758 * Wfw**0.0035 * (A/np.cos(L)**2)**0.6 * q**0.006 W = W * l**0.04 * (100*Rtc/np.cos(L))**(-0.3) * (Nz*Wdg)**(0.49) return(W) . Generating $100 times 100$ grid and checking interactions between $A$ (aspect ratio) and $N_z$ (ultimate load factor) keeping other parameters default. . x1 = x2 = np.linspace(0,1,100) A, Nz = np.meshgrid(x1, x2) wt = wingwt(A=A, Nz=Nz) fig, ax = plt.subplots() cntr = plt.contour(A, Nz, wt, levels=20);plt.xlabel(&#39;A&#39;);plt.ylabel(&#39;Nz&#39;); ticks = [0,0.2,0.4,0.6,0.8,1] plt.xticks(ticks);plt.yticks(ticks) ax.clabel(cntr); . Now, checking interactions between $ lambda$ (taper ratio) and $W_{fw}$ (weight of fuel in wing) in the same way. . x1 = x2 = np.linspace(0,1,100) l, Wfw = np.meshgrid(x1, x2) wt = wingwt(l=l, Wfw=Wfw) fig, ax = plt.subplots() cntr = plt.contour(l, Wfw, wt, levels=20);plt.xlabel(&#39;l&#39;);plt.ylabel(&#39;Wfw&#39;); ticks = [0,0.2,0.4,0.6,0.8,1] plt.xticks(ticks);plt.yticks(ticks) ax.clabel(cntr); . This interaction does not add a lot value in estimation of weight. . Generating grids for each pair (total $^9C_2$ = 36) and evaluating $100 times 100$ grid ($360K$ points) is not computationally tengible. We will use surrogate GP to learn the underlying phenomena using far lesser points. . Let&#39;s generate 1000 Latin Hypercube samples (LHS) for 9 dimensions of interest. . import pyDOE2 . X = pyDOE2.doe_lhs.lhs(9, 1000, random_state=0) plt.scatter(X[:,0], X[:,1], s=10); . Now, We will evaluate this input space in wingwt function to generate 1000 values for response variable weight. . Y = wingwt(*[X[:,i] for i in range(9)]) Y.shape . (1000,) . First we will try with 1st order polynomial regression with interaction terms. Let us use backward step selection, BIC criterion and 5 fold cv to select the best model. . from sklearn.linear_model import LinearRegression from sklearn.preprocessing import PolynomialFeatures trans = PolynomialFeatures(2, interaction_only=True, include_bias=False) from mlxtend.feature_selection import SequentialFeatureSelector as sfs model = LinearRegression() model.fit(trans.fit_transform(X)[:,[0,2,4,5,6,7,8,37]], np.log(Y)); ic = model.intercept_.round(4) coef = model.coef_.round(4) . print({&#39;Intercept&#39;:ic,&#39;Sw&#39;:coef[0],&#39;A&#39;:coef[1],&#39;q&#39;:coef[2],&#39;l&#39;:coef[3], &#39;Rtc&#39;:coef[4],&#39;Nz&#39;:coef[5],&#39;Wdg&#39;:coef[6],&#39;q:Nz&#39;:coef[7]}) . {&#39;Intercept&#39;: 5.0765, &#39;Sw&#39;: 0.2186, &#39;A&#39;: 0.305, &#39;q&#39;: 0.0048, &#39;l&#39;: 0.0278, &#39;Rtc&#39;: -0.2378, &#39;Nz&#39;: 0.4179, &#39;Wdg&#39;: 0.1882, &#39;q:Nz&#39;: 0.0028} . Interaction between A and Nz is not captured though we know it exists. . Now, We will fit a GP. . import GPy . GP = GPy.models.GPRegression(X, Y.reshape(-1,1), GPy.kern.RBF(input_dim=9, active_dims=list(range(9)), ARD=True)) GP.optimize() . /home/patel_zeel/anaconda3/lib/python3.8/site-packages/GPy/kern/src/stationary.py:243: RuntimeWarning:invalid value encountered in true_divide . &lt;paramz.optimization.optimization.opt_lbfgsb at 0x7faa16a0a4c0&gt; . Creating a $100 times 100$ grid of A and Nz and setting other parameters to baseline. . params = [] for param in range(9): param_val = wingwt.__defaults__[param]*np.ones((10000,1)) params.append(param_val) # Modify A and Nz at positions 2 and 7 params[2] = A.reshape(-1,1) params[7] = Nz.reshape(-1,1) # Create test grid XX = np.hstack(params) XX.shape . (10000, 9) . pred_Y, pred_Var = GP.predict(XX) . fig, ax = plt.subplots(1,2, sharex=True, sharey=True,figsize=(10,4)) cntr1 = ax[0].contour(A, Nz, pred_Y.reshape(100,100), levels=20); ax[0].clabel(cntr1); wt = wingwt(A=A, Nz=Nz) cntr2 = ax[1].contour(A, Nz, wt, levels=20); ax[1].clabel(cntr2); ticks = [0,0.2,0.4,0.6,0.8,1] for i in range(2): ax[i].set_xlabel(&#39;A&#39;);ax[i].set_ylabel(&#39;Nz&#39;); ax[i].set_xticks(ticks);ax[i].set_yticks(ticks) ax[0].set_title(&#39;Predicted response&#39;) ax[1].set_title(&#39;Baseline response&#39;); . We have successfully captured the relationship between $N_z, A$ and $W$ with 1000 simulated points. . Now, doing 1D sensitivity analysis for all 9 process variables . preds = [] for i in range(9): print(i,end=&#39;&#39;) params = [] for param in range(9): param_val = wingwt.__defaults__[param]*np.ones((1000,1)) params.append(param_val) # Modify ith parameter params[i] = np.linspace(0,1,1000).reshape(-1,1) # Create test grid XX = np.hstack(params) preds.append(GP.predict(XX)[0]) print(&#39; Done&#39;) # wingwt . 012345678 Done . plt.figure(figsize=(15,5)) param_names = [&#39;Sw&#39;,&#39;Wfw&#39;,&#39;A&#39;,&#39;L&#39;,&#39;q&#39;,&#39;l&#39;,&#39;Rtc&#39;,&#39;Nz&#39;,&#39;Wdg&#39;] for i in range(9): plt.plot(np.linspace(0,1,1000), preds[i], label=param_names[i]) plt.legend(bbox_to_anchor=[1,1]); plt.xlabel(&#39;Process variable&#39;);plt.ylabel(&#39;Response variable&#39;); . Variables l, L, Wfw and q are not very useful in determining yields of response variable. . Homework .",
            "url": "https://patel-zeel.github.io/Surrogates-GP-with-Python/gp/2021/02/18/Chap-1.html",
            "relUrl": "/gp/2021/02/18/Chap-1.html",
            "date": " • Feb 18, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://patel-zeel.github.io/Surrogates-GP-with-Python/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://patel-zeel.github.io/Surrogates-GP-with-Python/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}